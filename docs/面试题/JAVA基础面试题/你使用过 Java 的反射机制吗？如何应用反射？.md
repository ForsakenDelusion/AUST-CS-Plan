反射其实就是 Java 提供的能在**运行期**得到对象信息的能力，包括属性、方法、注解等，也可以调用其方法。

一般在业务编码中不会用到反射，在框架上用的较多，因为很多场景需要很灵活，不确定目标对象的类型，届时只能通过反射动态获取对象信息。

例如 Spring 使用反射机制来读取和解析配置文件，从而实现依赖注入和面向切面编程等功能。

比如动态代理场景可以使用反射机制在运行时动态地创建代理对象。

所以反射机制的优点是：

- 可以动态地获取类的信息，不需要在编译时就知道类的信息。
- 可以动态地创建对象，不需要在编译时就知道对象的类型。
- 可以动态地调用对象的属性和方法，在运行时动态地改变对象的行为。

虽然反射很灵活，但是它有个明显的缺点，**性能问题**。

如果正常调用没影响，但是在高并发场景下就一点性能问题就会放大。

之所以反射有性能问题是因为反射是在运行时进行的，所以程序每次反射解析检查方法的类型等都需要从 class 的类信息加载进行运行时的动态检查。

所以 Apache BeanUtils 的 copy 在高并发下就有性能问题。

如何优化呢？

缓存，例如把第一次得到的 Method 缓存起来，后续就不需要再调用 Class.getDeclaredMethod 也就不需要再次动态加载了，这样就可以避免反射性能问题。