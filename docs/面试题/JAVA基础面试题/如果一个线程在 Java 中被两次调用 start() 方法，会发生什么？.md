会报错！因为在 Java 中，一个线程只能被启动一次！所以尝试第二次调用 start() 方法时，会抛出 IllegalThreadStateException 异常。

这是因为**一旦线程已经开始执行，它的状态不能再回到初始状态**。线程的生命周期不允许它从终止状态回到可运行状态。

### 补充线程的生命周期

在 Java 中，线程的生命周期可以细化为以下几个状态：

- New（初始状态）：线程对象创建后，但未调用 start() 方法。
- Runnable（可运行状态）：调用 start() 方法后，线程进入就绪状态，等待 CPU 调度。
- Blocked（阻塞状态）：线程试图获取一个对象锁而被阻塞。
- Waiting（等待状态）：线程进入等待状态，需要被显式唤醒才能继续执行。
- Timed Waiting（含等待时间的等待状态）：线程进入等待状态，但指定了等待时间，超时后会被唤醒。
- Terminated（终止状态）：线程执行完成或因异常退出。

而 Blocked、Waiting、Timed Waiting 其实都属于休眠状态。

<img src="https://pic.code-nav.cn/mianshiya/question_picture/1783397053004488705/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f79657373696d6964612f63646e5f696d6167652f696d672f696d6167652d32303231303330373130303733323937302e706e67_mianshiya.png" alt="68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f79657373696d6964612f63646e5f696d6167652f696d672f696d6167652d32303231303330373130303733323937302e706e67.png" width="100%" />

一开始线程新建的时候就是初始状态，还未 start。

调用可运行状态就是可以运行。可能正在运行，也可能正在等 CPU 时间片。

造成线程等待的操作有：`Object.wait`、`Thread.join`、`LockSupport.park`。

含等待时间的等待就是上面这些操作设置了 timeout 参数的方法，例如`Object.wait(1000)`。

### 扩展：操作系统中线程的生命周期

操作系统中线程的生命周期通常包括以下五个阶段：

- 新建（New）：线程对象被创建，但尚未启动。
- 就绪（Runnable）：线程被启动，处于可运行状态，等待CPU调度执行。
- 运行（Running）：线程获得CPU资源，开始执行run()方法中的代码。
- 阻塞（Blocked）：线程因为某些操作（如等待锁、I/O操作）被阻塞，暂时停止执行。
- 终止（Terminated）：线程执行完成或因异常退出，生命周期结束。